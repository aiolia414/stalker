#!/usr/bin/env python
import json
import urllib2
import os
import sys
import optparse
from datetime import datetime

def _requeue(config, cid):
    target = config['url'] + '/checks/id/' + cid + '/next'
    headers = {'X-API-KEY': config['key'], 'Content-Type': 'application/json'}
    data = {'next': 'now'}
    try:
        req = urllib2.Request(target, json.dumps(data), headers=headers)
        res = urllib2.urlopen(req)
        content = res.read()
        print "%s set for recheck." % cid
    except urllib2.HTTPError as err:
        if err.code == 404:
            print "Error. No check with id %s" % cid
        else:
            print "Failed. Status: %s Msg: %s" % (err.code, err.reason)


def _state_log(config, target_check):
    host, check = target_check.split(':', 1)
    endpoint = '/state_log/%s/%s' % (host, check)
    url = config['url'] + endpoint
    headers = {'X-API-KEY': config['key'], 'Content-Type': 'application/json'}
    try:
        req = urllib2.Request(url, headers=headers)
        res = urllib2.urlopen(req)
        content = res.read()
        result = json.loads(content)
        print "## State Log for %s on %s ##" % (check, host)
        if len(result['state_log']) > 0:
            for entry in result['state_log']:
                ts = datetime.utcfromtimestamp(entry['last'])
                if entry['status']:
                    state = "UP  "
                else:
                    state = "DOWN"
                print "[%s] %s - %s" % (ts, state, entry['out'])
        else:
            print "No history yet..."
    except urllib2.HTTPError as err:
        if err.code == 404:
            print "Error. No check or check history for %s %s" % (host, check)
        else:
            print "Failed. Status: %s Msg: %s" % (err.code, err.reason)

def _remove_host(config, pattern):
    target = config['url'] + '/hosts/' + pattern
    headers = {'X-API-KEY': config['key'], 'Content-Type': 'application/json'}
    try:
        req = urllib2.Request(target, headers=headers)
        req.get_method = lambda: 'DELETE'
        res = urllib2.urlopen(req)
        content = res.read()
        print "%s deleted." % pattern
    except urllib2.HTTPError as err:
        if err.code == 404:
            print "Error. No host matching %s" % pattern
        else:
            print "Failed. Status: %s Msg: %s" % (err.code, err.reason)

def _remove_check(config, cid, name=None):
    target = config['url'] + '/checks/id/' + cid
    headers = {'X-API-KEY': config['key'], 'Content-Type': 'application/json'}
    try:
        req = urllib2.Request(target, headers=headers)
        req.get_method = lambda: 'DELETE'
        res = urllib2.urlopen(req)
        content = res.read()
        print "%s deleted." % (name or cid)
    except urllib2.HTTPError as err:
        if err.code == 404:
            print "Error. No check with id %s" % cid
        else:
            print "Failed. Status: %s Msg: %s" % (err.code, err.reason)


def _remove(config, pattern):
    print "Looking up checks for %s..." % pattern
    host = _get_checks_by_host(config, pattern)
    if host:
        if 'checks' in host:
            print [i['check'] for i in host['checks']]
            _ok = raw_input('Ok to remove all these checks? [y/n] ').strip().lower()
            if _ok != 'y':
                print "Aborting."
                return
            else:
                for check in host['checks']:
                    _remove_check(config, check['_id'], check['check'])
    print "Removing host..."
    _remove_host(config, pattern)


def _get_checks_by_host(config, pattern):
    target = config['url'] + '/checks/host/' + pattern
    headers = {'X-API-KEY': config['key'], 'Content-Type': 'application/json'}
    try:
        req = urllib2.Request(target, headers=headers)
        res = urllib2.urlopen(req)
        return json.loads(res.read())
    except urllib2.HTTPError as err:
        if err.code == 404:
            print "Error. No checks for %s" % pattern
        else:
            print "Failed. Status: %s Msg: %s" % (err.code, err.reason)


def _pjson(content):
    try:
        import pygments.lexers
        lexer = pygments.lexers.get_lexer_by_name(
            'javascript')  # just use this incase its an old version
        from pygments.formatters import TerminalFormatter
        from pygments import highlight
        print(highlight(content, lexer, TerminalFormatter()))
    except ImportError:
        # load and then dump to print
        output = json.loads(content)
        print json.dumps(output, sort_keys=False, indent=4)


def _request(config, rtype):
    endpoints = {'alerting': '/checks/state/alerting',
                 'pending': '/checks/state/pending',
                 'suspended': '/checks/state/suspended'}
    target = config['url'] + endpoints[rtype]
    headers = {'X-API-KEY': config['key']}
    req = urllib2.Request(target, headers=headers)
    res = urllib2.urlopen(req)
    content = res.read()
    parsed = json.loads(content)
    return content, parsed


def main():
    """stalkerweb cli"""
    usage = '''%prog -a -p -s -v'''
    args = optparse.OptionParser(usage)
    args.add_option('--alerting', '-a', action="store_true",
                    help="Get alerting")
    args.add_option('--pending', '-p', action="store_true",
                    help="Get pending")
    args.add_option('--suspended', '-s', action="store_true",
                    help="Get suspended")
    args.add_option('--verbose', '-v', action="store_true",
                    help="Print out json (fancy if pygments is present")
    args.add_option('--recheck', dest='recheck_id',
                    help="Recheck check with given id")
    args.add_option('--remove', dest='remove_host',
                    help="Remove all checks for given host or ip")
    args.add_option('--list', '-l', dest='list_host',
                    help="List all checks for given host or ip")
    args.add_option('--state-log', dest="state_log_target",
            help="Show the state log for a given target ex: --state-log=hostname:check_name")
    options, arguments = args.parse_args()

    conf_file = os.environ.get('stalker-client-conf',
                               '/etc/stalker/stalker-client.conf')

    config = {'url': None, 'key': None}

    if os.path.exists(conf_file):
        with open(conf_file) as f:
            for line in f:
                if line.startswith('stalkerweb_url'):
                    config['url'] = line.split('=')[1].strip().rstrip('/')
                elif line.startswith('stalkerweb_api_key'):
                    config['key'] = line.split('=')[1].strip()

    if os.environ.get('stalkerweb_url'):
        config['url'] = os.environ.get('stalkerweb_url').rstrip('/')

    if os.environ.get('stalkerweb_api_key'):
        config['key'] = os.environ.get('stalkerweb_api_key')

    if not config['url']:
        print "No stalkerweb_url found in env nor in %s" % conf_file
        sys.exit(1)
    if not config['key']:
        print "No stalkerweb_api_key found in env nor in %s" % conf_file
        sys.exit(1)

    if len(sys.argv) == 1:
        options.alerting = True
    if options.state_log_target:
        _state_log(config, options.state_log_target)
    if options.recheck_id:
        _requeue(config, options.recheck_id)
    if options.remove_host:
        _remove(config, options.remove_host)
    if options.list_host:
        host = _get_checks_by_host(config, options.list_host)
        if host:
            print json.dumps(host, sort_keys=False, indent=4)
    if options.alerting:
        failed_hosts = set()
        content, parsed = _request(config, 'alerting')
        if options.verbose:
            _pjson(content)
        else:
            print "=== Alerting ==="
            sorted_alerts = {}
            for i in parsed['alerting']:
                if i['hostname'] in sorted_alerts:
                    sorted_alerts[i['hostname']].append(i)
                else:
                    sorted_alerts[i['hostname']] = []
                    sorted_alerts[i['hostname']].append(i)
            for host in sorted_alerts:
                for i in sorted_alerts[host]:
                    clean_out = " ".join([x for x in i['out'].split('\n')])
                    if clean_out.startswith('<urlopen error [Errno'):
                        failed_hosts.add(i['hostname'])
                    else:
                        print '(%s) %s on %s is alerting because "%s"' % (i['_id'], i['check'],
                                                                          i['hostname'],
                                                                          clean_out)
            print "=== Alerting - unreachable ==="
            print " ".join([x for x in failed_hosts])
    if options.pending:
        content, parsed = _request(config, 'pending')
        if options.verbose:
            _pjson(content)
        else:
            print "=== Pending ==="
            for i in parsed['pending']:
                clean_out = " ".join([x for x in i['out'].split('\n')])
                print '%s on %s' % (i['check'], i['hostname'])
    if options.suspended:
        content, parsed = _request(config, 'suspended')
        if options.verbose:
            _pjson(content)
        else:
            print "=== Suspended ==="
            for i in parsed['suspended']:
                clean_out = " ".join([x for x in i['out'].split('\n')])
                print '%s on %s is suspended. last output: "%s"' % (i['check'], i['hostname'], clean_out)

if __name__ == '__main__':
    main()
